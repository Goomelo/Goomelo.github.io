{"total":2,"pageSize":10,"pageCount":1,"data":[{"title":"","slug":"setjmp.S分析","date":"2022-02-16T04:22:22.915Z","updated":"2022-02-16T04:22:22.954Z","comments":true,"path":"api/articles/setjmp.S分析.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"setjmp-S分析\"><a href=\"#setjmp-S分析\" class=\"headerlink\" title=\"setjmp.S分析\"></a>setjmp.S分析</h1><h2 id=\"如何使用setjmp\"><a href=\"#如何使用setjmp\" class=\"headerlink\" title=\"如何使用setjmp\"></a>如何使用setjmp</h2><p>setjmp一般会创建本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为0。如果是从longjmp恢复的程序调用环境返回，setjmp返回非零值。</p>\n<p>示例程序如下所示：</p>\n<pre><code>1 #include &lt;stdio.h&gt;\n2 #include &lt;setjmp.h&gt;\n3 static jmp_buf buf;\n4 void func()&#123;\n5     printf(&quot;in func\\n&quot;);\n6     longjmp(buf,1);\n7 &#125;\n8 int main()&#123;\n9     if(setjmp(buf)) &#123;\n10         printf(&quot;after jmp\\n&quot;);\n11     &#125;else&#123;\n12         func();\n13     &#125;\n14     return 0;\n15 &#125;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code>in func\nafter jmp\n</code></pre>\n<p>可以看出第一次运行到setjmp时，setjmp的返回值为0并且进入else分支，进入func（）函数中，在func（）函数中会调用longjmp，并返回到上一次调用setjmp的地方接着运行，并且本次setjmp的返回值为longjmp的第二个参数，本例为1.</p>\n<h2 id=\"如何实现setjmp\"><a href=\"#如何实现setjmp\" class=\"headerlink\" title=\"如何实现setjmp\"></a>如何实现setjmp</h2><p>setjmp和goto有一些不同，setjmp是可以支持在函数间跳转的non-local jump，换言之，goto只能在函数内部的标签之间进行跳转。</p>\n<p>不难看出，让longjmp返回到setjmp上一次调用位置，起到作用的应该是全局变量buf，即setjmp将调用函数的信息保存在buf中，而下一次buf作为参数传入longjmp时，longjmp会根据buf中的信息返回到上一次调用setjmp的位置。</p>\n<h2 id=\"RVI的aosp中Bionic库setjmp-S实现\"><a href=\"#RVI的aosp中Bionic库setjmp-S实现\" class=\"headerlink\" title=\"RVI的aosp中Bionic库setjmp.S实现\"></a>RVI的aosp中Bionic库setjmp.S实现</h2><p>这里我们将setjmp.S分开阅读，首先看到两个函数入口，分别是_setjmp和setjmp：</p>\n<pre><code>ENTRY(setjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(setjmp)\n    li    a1, 1\n#ifdef __PIC__\n    auipc    a2, 0\n    /* FIXME:riscv */\n    jalr    x0, 42(a2)\n#else\n    j    sigsetjmp\n#endif\nEND(setjmp)\n\nENTRY(_setjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(_setjmp)\n    li    a1, 0\n#ifdef __PIC__\n    auipc    a2, 0\n    jalr    x0, 18(a2)\n#else\n    j    sigsetjmp\n#endif\nEND(_setjmp)\n</code></pre>\n<p>可以看到这两个函数的不同点在于load immediate指令，a1寄存器即返回值的值分别为0，1，共同点在于非PIC时，会跳转到sigestjmp函数，那么我们接着看一下sigsetjmp。</p>\n<pre><code>// int sigsetjmp(sigjmp_buf env, int save_signal_mask);\nENTRY(sigsetjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(sigsetjmp)\n    addi    sp, sp, -24\n    sd    a0, 8(sp)\n    sd    ra, 16(sp)\n\n    mv    a0, a1\n#ifdef __PIC__\n    call    __bionic_setjmp_cookie_get@plt\n#else\n    j    __bionic_setjmp_cookie_get\n#endif\n    mv    a1, a0\n    ld      a0, 8(sp)\n    sd    a1, 0(a0)\n    andi    a1, a1, 1\n\n    beqz    a1, 1f\n\n    li    a1, 0\n    addi    a2, a0, 8\n#ifdef __PIC__\n    call    sigprocmask@plt\n#else\n    j    sigprocmask\n#endif\n    ld    a1, 0(sp)\n1:\n    ld    a0, 8(sp)\n    ld    ra, 16(sp)\n    addi    sp, sp, 24\n    \n        sd    ra, 16(a0)\n        sd    s0, 24(a0)\n        sd    s1, 32(a0)\n        sd    s2, 40(a0)\n        sd    s3, 48(a0)\n        sd    s4, 56(a0)\n        sd    s5, 64(a0)\n        sd    s6, 72(a0)\n        sd    s7, 80(a0)\n        sd    s8, 88(a0)\n        sd    s9, 96(a0)\n        sd    s10, 104(a0)\n        sd    s11, 112(a0)\n        sd    sp, 120(a0)\n\n        fsd    fs0, 128(a0)\n        fsd    fs1, 136(a0)\n        fsd    fs2, 144(a0)\n        fsd    fs3, 152(a0)\n        fsd    fs4, 160(a0)\n        fsd    fs5, 168(a0)\n        fsd    fs6, 176(a0)\n        fsd    fs7, 184(a0)\n        fsd    fs8, 192(a0)\n        fsd    fs9, 200(a0)\n        fsd    fs10, 208(a0)\n        fsd    fs11, 216(a0)\n\n    li    a0, 0\n    ret\nEND(sigsetjmp)\n</code></pre>\n<p>sigsetjmp函数比较长，但是可以主要分为三部分，即riscv进行函数调用的prologue部分，一些信息的处理部分和最后信息将寄存器保存到内存中的部分（包括整型和浮点型）。</p>\n<p>首先看第一部分就是riscv标准的函数调用prologue部分，即</p>\n<pre><code>    addi    sp, sp, -24\n    sd    a0, 8(sp)\n    sd    ra, 16(sp)\n</code></pre>\n<p>可以看到这里是将栈地址向高地址移动24（riscv是小端模式，栈移动一般以8为单位），并且将a0和ra压入栈中。</p>\n<p>再看到下面很长遗传的sd和fsd指令，可以看出这部分setjmp的行为是将调用函数部分的信息写入到全局变量buf中以便下一次恢复。每一个sd或fsd都是将寄存器的值存入buf中，其中大部分寄存器中的内容对于我们可能并非多么重要，我们只需要重点关注三个寄存器的值：</p>\n<pre><code>    sd    ra, 16(a0)\n    sd    s0, 24(a0)\n    sd    sp, 120(a0)\n</code></pre>\n<p>可以看出将ra、s0、sp寄存器的值存入buf（a0寄存器保存了函数调用参数）中，并且stack pointer和frame pointer也都被存入buf中，以便下一次恢复到当前位置。</p>\n<p>结束时将a0寄存器置0，原因是第一次调用setjmp时将会返回0。</p>\n<p>longjmp的实现如下：</p>\n<pre><code>// void siglongjmp(sigjmp_buf env, int value);\nENTRY(siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(siglongjmp)\n    ld    a2, 0(a0)\n    andi    a2, a2, 1\n    beqz    a2, 1f\n\n    addi    sp, sp, -16\n    sd    a0, 0(sp)\n    sd    ra, 8(sp)\n\n    mv    t0, a1\n\n    mv    a2, a0\n    li    a0, 2\n    addi    a1, a2, 8\n    li    a2, 0\n#ifdef __PIC__\n    call    sigprocmask@plt\n#else\n    j    sigprocmask\n#endif\n    mv    a1, t0\n\n    ld    a0, 0(sp)\n    ld    ra, 8(sp)\n    addi    sp, sp, 16\n\n    ld      a2, 0(a0)\n1:\n        ld    ra, 16(a0)\n        ld    s0, 24(a0)\n        ld    s1, 32(a0)\n        ld    s2, 40(a0)\n        ld    s3, 48(a0)\n        ld    s4, 56(a0)\n        ld    s5, 64(a0)\n        ld    s6, 72(a0)\n        ld    s7, 80(a0)\n        ld    s8, 88(a0)\n        ld    s9, 96(a0)\n        ld    s10, 104(a0)\n        ld    s11, 112(a0)\n        ld    sp, 120(a0)\n\n    addi    sp, sp, -24\n    sd    ra, 0(sp)\n    sd    a0, 8(sp)\n    sd    a1, 16(sp)\n    ld    a0, 0(a0)\n#ifdef __PIC__\n    call    __bionic_setjmp_cookie_check@plt\n#else\n    jal    __bionic_setjmp_cookie_check\n#endif\n    ld    ra, 0(sp)\n    ld    a0, 8(sp)\n    ld    a1, 16(sp)\n    addi    sp, sp, 24\n\n        fld    fs0, 128(a0)\n        fld    fs1, 136(a0)\n        fld    fs2, 144(a0)\n        fld    fs3, 152(a0)\n        fld    fs4, 160(a0)\n        fld    fs5, 168(a0)\n        fld    fs6, 176(a0)\n        fld    fs7, 184(a0)\n        fld    fs8, 192(a0)\n        fld    fs9, 200(a0)\n        fld    fs10, 208(a0)\n        fld    fs11, 216(a0)\n\n    // Set return value.\n    beqz    a1, 2f\n    li    a0, 1\n2:\n    mv    a0, a1\n    ret\nEND(siglongjmp)\nALIAS_SYMBOL(longjmp, siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(longjmp)\nALIAS_SYMBOL(_longjmp, siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(_longjmp)\n</code></pre>\n<p>可以看出这里使用ALIAS_SYMBOL将longjmp全部当作siglongjmp处理。细看实现，可以发现，和setjmp类似，这里主要操作在于将buf中的值load回寄存器中，最后进行了判断，</p>\n<pre><code>    beqz    a1, 2f\n    li    a0, 1\n2:\n    mv    a0, a1\n    ret\n</code></pre>\n<p>这里可以看到会判断a1是否等于0，如果是的话将跳转到2位置即将a1的值（第二个参数）当作返回值，否则返回值为1，也符合定义，然后将回到ra中指定的地址从而恢复buf。</p>\n","text":"setjmp.S分析如何使用setjmpsetjmp一般会创建本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为0。如果是从longj","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"build AOSP on riscv (尝试参与AOSP在riscv上移植)","slug":"AOSP-on-riscv","date":"2021-12-21T17:36:48.000Z","updated":"2022-02-18T06:46:56.470Z","comments":true,"path":"api/articles/AOSP-on-riscv.json","excerpt":"","keywords":null,"cover":null,"content":"<p>首先感谢软件所PLCT实验室汪辰老师的文章，带我入门了aosp的一些基本概念并且跟着老师的教程完成了环境的搭建。</p>\n<p>本来是想用英文记录下整个参与过程，但是英语水平有限。</p>\n<p>机缘巧合是之前稍稍入坑了安卓开发，稍微了解了一下基于安卓的构建之后，发现了aosp官方一直在维护的仓库，又了解到了国内有一批<br>人（没错就是平头哥）做了aosp在riscv上的移植，而我又十分看好riscv的未来，也非常欣赏riscv的设计，因此想到了有没有机会来参与一下<br>aosp在riscv上的移植。</p>\n<p>本文大概的框架非常简单，因为主要是记录参与AOSP移植的一些过程，记录一些踩过的坑，因此首先会介绍AOSP的基本概念，<br>包括AOSP的前置知识包括仓库里的版本管理等知识，之后会介绍我在使用riscv工具链编译Linux的一些小小经验（当然工具链的验证<br>等工作都由PLCT的前辈完成，本人只是做一些拾人牙慧的操作），最后是基于qemu上riscv-64位内核编译Linux以及编译riscv-64 AOSP的经验。</p>\n<h1 id=\"关于AOSP你需要知道什么\"><a href=\"#关于AOSP你需要知道什么\" class=\"headerlink\" title=\"关于AOSP你需要知道什么\"></a>关于AOSP你需要知道什么</h1><p>AOSP是Android Open Source Project的简称，即安卓开源项目，实际上就是安卓开源系统啦，我们所熟知的MIUI，H2OS等等用在安卓手机伤的操作系统，<br>大都是基于AOSP进行开发的。官方仓库可以在这里获取：<a href=\"https://source.android.com/?hl=zh-cn\">https://source.android.com/?hl=zh-cn</a></p>\n<p>众所周知安卓系统可以看作是运行在移动设备上的Linux系统，虽然Android+Arm的生态环境几乎已经形成类似WinTel一般牢不可破的联盟，但笔者依然看好Riscv<br>在移动市场的未来前景，因此看到了aosp on riscv的相关项目便义无反顾入了坑。</p>\n<h2 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h2><p>版本管理在21世纪的今天已经不是陌生的概念，而面对AOSP这样庞大的时逾15年的大型开源项目就更为重要。</p>\n<p>安卓的每一个开发版本有一个叫做platform的概念，基于此Google提出了三个与版本管理相关的概念：</p>\n<ul>\n<li>每个Platform有一个唯一用于标示的版本号Version，这当然非常易于理解。版本号采用点分格式，即X.Y.Z的格式，<br>一般简写为X或X.Y，从1.0开始一直到目前发现的11。</li>\n<li>Google也是个很有意思的公司，因此不同的发行版也会有一个独立的Codename，有点类似macos起昵称的感觉，还是<br>蛮可爱的设定。当然Codename和Version是一对多的概念，用过macos的小伙伴应该可以理解。</li>\n<li>与Version对应的概念是API level，顾名思义就是该Version提供给上层应用的编程接口，因此API level对应的<br>Version是唯一的。</li>\n</ul>\n<p>与之相关更关，在Platform层面更细的概念就是tag和build了，tag与git里的tag类似，build则是google的构建版本，<br>在此不再赘述。（本来还想写一点关于构建工具的文章，但是感觉完全没有个人产出了，有点生搬硬套的感觉，遂放弃）。</p>\n<h3 id=\"内核版本管理\"><a href=\"#内核版本管理\" class=\"headerlink\" title=\"内核版本管理\"></a>内核版本管理</h3><p>如果有build过Linux内核经验的同学，应该对这个概念并不陌生，本文主要介绍的是AOSP内核，因其使用的Linux内核是在原生Linux内核上，<br>加了一些安卓系统所需的特性（根据wangchen老师的说法是短期内还没有被Linux接纳，以至于未被合并到Linux upstream的补丁程序）。</p>\n<p>总而言之，随着Linux内核的不断演进发展以及Android内核自身的演进，对于AOSP内核管理最重要的事情就是管理好Linux内核与AOSP内核之间的关系，<br>包括如何利用上Linux upstream上的新功能和特性，兼容之后之前的特性等等。</p>\n<h4 id=\"Linux内核\"><a href=\"#Linux内核\" class=\"headerlink\" title=\"Linux内核\"></a>Linux内核</h4><p>从 2003 年 12 月往后，也就是 从 2.6内核版本发布往后，内核开发者社区从之前维护单独的一个开发分支和另一个稳定分支的模型迁移到只维护一个 “稳定” 分支模型。<br>在此模式下，每 2-3 个月就会发布一次新版本，出现这种变化的原因在于：2.6 版本内核之前的版本周期非常长（将近 3 年），且同时维护两个不同的代码库难度太高。</p>\n<p>内核版本的编号从 2.6.x 开始，其中 x 是一个数字，会在每次发布新版本时递增（除了表示此版本比上一内核版本更新之外，该数字的值不具有任何意义）。内核版本发展到现在已经进入 5 系列（最新的是 5.8.x）。<br>在众多内核版本中，分为 mainline 即主线版本，stable 稳定版本和 longterm 长期维护版本。其中 mainline 版本由 Linus 本人维护，每两到三个月会做一次升级，而且是两位数字版本号，<br>不涉及第三位数字，譬如 5.1、5.2、5.3 ……。stable 版本是针对 mainline 版本你的小版本更新，譬如对应 5.1 的会有 5.1.1、5.1.2、5.1.3 ……。某一些 stable 版本会被指定为 longterm 版本（也称为 LTS），<br>从而拥有更长的维护周期，直白了说就是其第三位数字会会变得很大。<br>（这段偷懒了直接复制了）</p>\n<h4 id=\"AOSP内核\"><a href=\"#AOSP内核\" class=\"headerlink\" title=\"AOSP内核\"></a>AOSP内核</h4><p>AOSP内核主要了解的概念是”Android platform release”概念，Google基本保持一年一更新的概念。<br>其中Launch Kernel的概念即AOSP内核用于发布在新设备上的版本，Feature Kernel则是为了支持Android某个Platform新特性的类似布丁的更新。</p>\n","text":"首先感谢软件所PLCT实验室汪辰老师的文章，带我入门了aosp的一些基本概念并且跟着老师的教程完成了环境的搭建。本来是想用英文记录下整个参与过程，但是英语水平有限。机缘巧合是之前稍稍入坑了安卓开发，稍微了解了一下基于安卓的构建之后，发现了aosp官方一直在维护的仓库，又了解到了国","link":"","raw":null,"photos":[],"categories":[],"tags":[]}]}