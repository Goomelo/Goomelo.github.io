{"title":"aosp_setjmp.S","slug":"aosp-setjmp-S","date":"2022-02-18T06:52:51.000Z","updated":"2022-02-18T06:54:54.851Z","comments":true,"path":"api/articles/aosp-setjmp-S.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"setjmp-S分析\"><a href=\"#setjmp-S分析\" class=\"headerlink\" title=\"setjmp.S分析\"></a>setjmp.S分析</h1><h2 id=\"如何使用setjmp\"><a href=\"#如何使用setjmp\" class=\"headerlink\" title=\"如何使用setjmp\"></a>如何使用setjmp</h2><p>setjmp一般会创建本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为0。如果是从longjmp恢复的程序调用环境返回，setjmp返回非零值。</p>\n<p>示例程序如下所示：</p>\n<pre><code>1 #include &lt;stdio.h&gt;\n2 #include &lt;setjmp.h&gt;\n3 static jmp_buf buf;\n4 void func()&#123;\n5     printf(&quot;in func\\n&quot;);\n6     longjmp(buf,1);\n7 &#125;\n8 int main()&#123;\n9     if(setjmp(buf)) &#123;\n10         printf(&quot;after jmp\\n&quot;);\n11     &#125;else&#123;\n12         func();\n13     &#125;\n14     return 0;\n15 &#125;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code>in func\nafter jmp\n</code></pre>\n<p>可以看出第一次运行到setjmp时，setjmp的返回值为0并且进入else分支，进入func（）函数中，在func（）函数中会调用longjmp，并返回到上一次调用setjmp的地方接着运行，并且本次setjmp的返回值为longjmp的第二个参数，本例为1.</p>\n<h2 id=\"如何实现setjmp\"><a href=\"#如何实现setjmp\" class=\"headerlink\" title=\"如何实现setjmp\"></a>如何实现setjmp</h2><p>setjmp和goto有一些不同，setjmp是可以支持在函数间跳转的non-local jump，换言之，goto只能在函数内部的标签之间进行跳转。</p>\n<p>不难看出，让longjmp返回到setjmp上一次调用位置，起到作用的应该是全局变量buf，即setjmp将调用函数的信息保存在buf中，而下一次buf作为参数传入longjmp时，longjmp会根据buf中的信息返回到上一次调用setjmp的位置。</p>\n<h2 id=\"RVI的aosp中Bionic库setjmp-S实现\"><a href=\"#RVI的aosp中Bionic库setjmp-S实现\" class=\"headerlink\" title=\"RVI的aosp中Bionic库setjmp.S实现\"></a>RVI的aosp中Bionic库setjmp.S实现</h2><p>这里我们将setjmp.S分开阅读，首先看到两个函数入口，分别是_setjmp和setjmp：</p>\n<pre><code>ENTRY(setjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(setjmp)\nli    a1, 1\n#ifdef __PIC__\nauipc    a2, 0\n/* FIXME:riscv */\njalr    x0, 42(a2)\n#else\nj    sigsetjmp\n#endif\nEND(setjmp)\n\nENTRY(_setjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(_setjmp)\nli    a1, 0\n#ifdef __PIC__\nauipc    a2, 0\njalr    x0, 18(a2)\n#else\nj    sigsetjmp\n#endif\nEND(_setjmp)\n</code></pre>\n<p>可以看到这两个函数的不同点在于load immediate指令，a1寄存器即返回值的值分别为0，1，共同点在于非PIC时，会跳转到sigestjmp函数，那么我们接着看一下sigsetjmp。</p>\n<pre><code>// int sigsetjmp(sigjmp_buf env, int save_signal_mask);\nENTRY(sigsetjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(sigsetjmp)\naddi    sp, sp, -24\nsd    a0, 8(sp)\nsd    ra, 16(sp)\n\nmv    a0, a1\n#ifdef __PIC__\ncall    __bionic_setjmp_cookie_get@plt\n#else\nj    __bionic_setjmp_cookie_get\n#endif\nmv    a1, a0\nld      a0, 8(sp)\nsd    a1, 0(a0)\nandi    a1, a1, 1\n\nbeqz    a1, 1f\n\nli    a1, 0\naddi    a2, a0, 8\n#ifdef __PIC__\ncall    sigprocmask@plt\n#else\nj    sigprocmask\n#endif\nld    a1, 0(sp)\n1:\nld    a0, 8(sp)\nld    ra, 16(sp)\naddi    sp, sp, 24\n\nsd    ra, 16(a0)\nsd    s0, 24(a0)\nsd    s1, 32(a0)\nsd    s2, 40(a0)\nsd    s3, 48(a0)\nsd    s4, 56(a0)\nsd    s5, 64(a0)\nsd    s6, 72(a0)\nsd    s7, 80(a0)\nsd    s8, 88(a0)\nsd    s9, 96(a0)\nsd    s10, 104(a0)\nsd    s11, 112(a0)\nsd    sp, 120(a0)\n\nfsd    fs0, 128(a0)\nfsd    fs1, 136(a0)\nfsd    fs2, 144(a0)\nfsd    fs3, 152(a0)\nfsd    fs4, 160(a0)\nfsd    fs5, 168(a0)\nfsd    fs6, 176(a0)\nfsd    fs7, 184(a0)\nfsd    fs8, 192(a0)\nfsd    fs9, 200(a0)\nfsd    fs10, 208(a0)\nfsd    fs11, 216(a0)\n\nli    a0, 0\nret\nEND(sigsetjmp)\n</code></pre>\n<p>sigsetjmp函数比较长，但是可以主要分为三部分，即riscv进行函数调用的prologue部分，一些信息的处理部分和最后信息将寄存器保存到内存中的部分（包括整型和浮点型）。</p>\n<p>首先看第一部分就是riscv标准的函数调用prologue部分，即</p>\n<pre><code>addi    sp, sp, -24\nsd    a0, 8(sp)\nsd    ra, 16(sp)\n</code></pre>\n<p>可以看到这里是将栈地址向高地址移动24（riscv是小端模式，栈移动一般以8为单位），并且将a0和ra压入栈中。</p>\n<p>再看到下面很长遗传的sd和fsd指令，可以看出这部分setjmp的行为是将调用函数部分的信息写入到全局变量buf中以便下一次恢复。每一个sd或fsd都是将寄存器的值存入buf中，其中大部分寄存器中的内容对于我们可能并非多么重要，我们只需要重点关注三个寄存器的值：</p>\n<pre><code>sd    ra, 16(a0)\nsd    s0, 24(a0)\nsd    sp, 120(a0)\n</code></pre>\n<p>可以看出将ra、s0、sp寄存器的值存入buf（a0寄存器保存了函数调用参数）中，并且stack pointer和frame pointer也都被存入buf中，以便下一次恢复到当前位置。</p>\n<p>结束时将a0寄存器置0，原因是第一次调用setjmp时将会返回0。</p>\n<p>longjmp的实现如下：</p>\n<pre><code>// void siglongjmp(sigjmp_buf env, int value);\nENTRY(siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(siglongjmp)\nld    a2, 0(a0)\nandi    a2, a2, 1\nbeqz    a2, 1f\n\naddi    sp, sp, -16\nsd    a0, 0(sp)\nsd    ra, 8(sp)\n\nmv    t0, a1\n\nmv    a2, a0\nli    a0, 2\naddi    a1, a2, 8\nli    a2, 0\n#ifdef __PIC__\ncall    sigprocmask@plt\n#else\nj    sigprocmask\n#endif\nmv    a1, t0\n\nld    a0, 0(sp)\nld    ra, 8(sp)\naddi    sp, sp, 16\n\nld      a2, 0(a0)\n1:\nld    ra, 16(a0)\nld    s0, 24(a0)\nld    s1, 32(a0)\nld    s2, 40(a0)\nld    s3, 48(a0)\nld    s4, 56(a0)\nld    s5, 64(a0)\nld    s6, 72(a0)\nld    s7, 80(a0)\nld    s8, 88(a0)\nld    s9, 96(a0)\nld    s10, 104(a0)\nld    s11, 112(a0)\nld    sp, 120(a0)\n\naddi    sp, sp, -24\nsd    ra, 0(sp)\nsd    a0, 8(sp)\nsd    a1, 16(sp)\nld    a0, 0(a0)\n#ifdef __PIC__\ncall    __bionic_setjmp_cookie_check@plt\n#else\njal    __bionic_setjmp_cookie_check\n#endif\nld    ra, 0(sp)\nld    a0, 8(sp)\nld    a1, 16(sp)\naddi    sp, sp, 24\n\nfld    fs0, 128(a0)\nfld    fs1, 136(a0)\nfld    fs2, 144(a0)\nfld    fs3, 152(a0)\nfld    fs4, 160(a0)\nfld    fs5, 168(a0)\nfld    fs6, 176(a0)\nfld    fs7, 184(a0)\nfld    fs8, 192(a0)\nfld    fs9, 200(a0)\nfld    fs10, 208(a0)\nfld    fs11, 216(a0)\n\n// Set return value.\nbeqz    a1, 2f\nli    a0, 1\n2:\nmv    a0, a1\nret\nEND(siglongjmp)\nALIAS_SYMBOL(longjmp, siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(longjmp)\nALIAS_SYMBOL(_longjmp, siglongjmp)\n__BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(_longjmp)\n</code></pre>\n<p>可以看出这里使用ALIAS_SYMBOL将longjmp全部当作siglongjmp处理。细看实现，可以发现，和setjmp类似，这里主要操作在于将buf中的值load回寄存器中，最后进行了判断，</p>\n<pre><code>beqz    a1, 2f\nli    a0, 1\n2:\nmv    a0, a1\nret\n</code></pre>\n<p>这里可以看到会判断a1是否等于0，如果是的话将跳转到2位置即将a1的值（第二个参数）当作返回值，否则返回值为1，也符合定义，然后将回到ra中指定的地址从而恢复buf。</p>\n","categories":[],"tags":[]}